{"version":3,"file":"core-components.min.js","sources":["../packages/core-dialog/core-dialog.js","../packages/utils.js","../packages/core-input/core-input.js","../packages/core-dialog/core-dialog.jsx","../packages/core-input/core-input.jsx"],"sourcesContent":["import {attr, getElements, weakState} from '../utils'\n\nlet BACKDROP\nconst KEY = 'dialog-@VERSION'\nconst KEY_UNIVERSAL = 'data-dialog-xxx'\nconst FOCUSABLE_ELEMENTS = `\n  [tabindex]:not([disabled]),\n  button:not([disabled]),\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled])`\n\n// Attempt to focus on an autofocus target first. If none exists we will focus\n// on the first focusable element.\nconst focusOnFirstFocusableElement = (el) => {\n  const autofocusElement = el.querySelector('[autofocus]:not([disabled])')\n  const focusableElement = el.querySelector(FOCUSABLE_ELEMENTS)\n  ;(autofocusElement || focusableElement || el).focus()\n}\n\nconst getHighestZIndex = () =>\n  getElements('*').reduce((zIndex, el) =>\n    Math.max(zIndex, Number(window.getComputedStyle(el, null).getPropertyValue('z-index')) || 0)\n  , 0)\n\nconst getActive = () => document.querySelector(`[${KEY_UNIVERSAL}]`)\n\nconst setActiveStateForElement = (el) => {\n  const prevActive = getActive()\n  prevActive && prevActive.removeAttribute(KEY_UNIVERSAL)\n  el.setAttribute(KEY_UNIVERSAL, '')\n\n  return weakState(el, {\n    prevActive,\n    focusBeforeModalOpen: document.activeElement\n  }).get(el)\n}\n\n// Will toggle the open state of the dialog depending on what the fn function\n// returns or what (Boolean) value fn has.\nconst toggle = (el, index, fn, open = true) => {\n  const isOpen = Boolean(typeof fn === 'function' ? fn(el, index) : fn) === open\n\n  attr(el, {open: isOpen ? '' : null})\n  if (isOpen) {\n    el.style.zIndex = getHighestZIndex() + 1\n    setActiveStateForElement(el)\n    focusOnFirstFocusableElement(el)\n    BACKDROP.hidden = false\n    weakState().get(el).onOpenCallback && weakState().get(el).onOpenCallback()\n    // set focus\n  } else {\n    if (!weakState().get(el)) { return }\n    BACKDROP.hidden = !(weakState().get(el).prevActive)\n    el.removeAttribute(KEY_UNIVERSAL)\n    if (!BACKDROP.hidden) {\n      weakState().get(el).prevActive.setAttribute(KEY_UNIVERSAL, '')\n    }\n    // Should be able to pop when removing as the last element is the active dialog\n    const state = weakState().get(el)\n    // Focus on the last focused thing before the dialog modal was opened\n    state.focusBeforeModalOpen && state.focusBeforeModalOpen.focus()\n    // Delete state for element\n    // weakState(el, false)\n    weakState().get(el).onCloseCallback && weakState().get(el).onCloseCallback()\n  }\n}\n\nconst keepFocus = (event) => {\n  const activeDialog = getActive()\n  // If no dialog is active, we don't need to do anything\n  if (!activeDialog) { return }\n\n  const state = weakState().get(activeDialog)\n  const focusable = activeDialog.querySelectorAll(FOCUSABLE_ELEMENTS)\n\n  // If focus moves us outside the dialog, we need to refocus to inside the dialog\n  if (!activeDialog.contains(event.target)) {\n    state.activeElement === focusable[0] ? focusable[focusable.length - 1].focus() : focusable[0].focus()\n  } else {\n    state.activeElement = event.target\n  }\n}\n\nconst exitOnEscape = (event) => {\n  if (event.keyCode === 27) dialog(getActive()).close()\n}\n\nexport function dialog (selector, options = {}) {\n  if (!(this instanceof dialog)) return new dialog(selector, options) //eslint-disable-line\n\n  // Initialize the element with necessary attributes for a dialog\n  this.elements = attr(getElements(selector), {\n    role: 'dialog',\n    tabindex: -1,\n    'aria-modal': true\n  })\n\n  // Set the callbacks to each element\n  this.elements.forEach((el) => {\n    if (!weakState().get(el)) {\n      weakState().set(el, {\n        onOpenCallback: options.onOpenCallback,\n        onCloseCallback: options.onCloseCallback\n      })\n    }\n  })\n\n  return this\n}\n\ndialog.prototype.open = function (fn = true) {\n  this.elements.forEach((el, index) => toggle(el, index, fn))\n  return this\n}\n\ndialog.prototype.close = function (fn = false) {\n  this.elements.forEach((el, index) => toggle(el, index, fn))\n  return this\n}\n\nexport function createBackdrop () {\n  attr(BACKDROP = document.createElement('div'), {hidden: true, id: KEY})\n  // @todo: General styling. Should be removed?\n  BACKDROP.classList.add('nrk-dialog-backdrop')\n  document.addEventListener('focus', keepFocus, true)\n  document.addEventListener('keydown', exitOnEscape)\n  document.documentElement.appendChild(BACKDROP)\n}\n\nif (typeof document !== 'undefined' && !document.getElementById(KEY)) {\n  createBackdrop()\n}\n","const KEY = `core-components-${Date.now()}`\nconst STATES = {}\nlet UUID = 0\n\nexport function assign (target, ...sources) {\n  sources.filter(Boolean).forEach((source) => {\n    Object.keys(source).forEach((key) => (target[key] = source[key]))\n  })\n  return target\n}\n\nexport function attr (elements, attributes) {\n  getElements(elements).forEach((element) => {\n    Object.keys(attributes).forEach((name) => {\n      element[`${attributes[name] === null ? 'remove' : 'set'}Attribute`](name, attributes[name])\n    })\n  })\n  return elements\n}\n\nexport const closest = (element, nodeName) => {\n  for (var el = element; el; el = el.parentElement) {\n    if (el.nodeName.toLowerCase() === nodeName) return el\n  }\n}\n\nexport function on (key, event, handler) {\n  if (typeof window === 'undefined') return\n  const namespace = window[key] = window[key] || {}\n  const isUnbound = !namespace[event] && (namespace[event] = 1)\n\n  if (isUnbound) {\n    document.addEventListener(event, function (event) {\n      for (let el = event.target; el; el = el.parentElement) {\n        if (el[key]) handler(el, event)\n      }\n    }, true) // Use capture to make sure focus/blur bubbles in old Firefox\n  }\n}\n\nexport function getElements (elements, key) {\n  let list = []\n  if (typeof elements === 'string') list = [].slice.call(document.querySelectorAll(elements))\n  else if (elements && elements.length) list = [].slice.call(elements)\n  else if (elements && elements.nodeType) list = [elements]\n  if (key) list.forEach((el) => (el[key] = 1))\n  return list\n}\n\nexport function weakState (element, object, initial = {}) {\n  const weakMap = {\n    get: (element) => STATES[element[KEY]],\n    set: (element, object) => {\n      const uuid = element[KEY] || (element[KEY] = ++UUID)\n      const state = STATES[uuid] || (STATES[uuid] = initial)\n      Object.keys(object).forEach((key) => (state[key] = object[key]))\n      return state\n    },\n    has: (element) => Boolean(STATES[element[KEY]]),\n    delete: (element) => {\n      if (!weakMap.get(element)) return false\n      delete element[KEY]\n      delete STATES[element[KEY]]\n      return true\n    }\n  }\n\n  if (object === false) {\n    weakMap.delete(element)\n  } else if (typeof object === 'object') {\n    weakMap.set(element, object)\n  }\n\n  return weakMap\n}\n\nexport const queryAll = (selector, context = document) =>\n  [].slice.call(context.querySelectorAll(selector))\n","import {attr} from '../utils'\n\nconst KEY = 'input-@VERSION'\nlet LIST // Element to contain list\nlet LIVE // Element to contain screen reader text\n\nfunction render (elem) {\n  const state = elem[KEY]\n  const value = state.value.trim().toLowerCase()\n  state.hits = state.items.filter((item) => item.value.toLowerCase().indexOf(value) !== -1)\n\n  attr(LIVE, {'aria-hidden': false})\n  attr(LIST, {'hidden': state.hits.length ? null : true})\n  attr(elem, {'aria-expanded': Boolean(state.hits.length)})\n\n  LIST.style.width = `${elem.offsetWidth}px`\n  LIST.innerHTML = state.hits.map(({value}, i) =>\n    `<li role=\"option\" aria-selected=\"${i === state.index}\">${value}</li>`\n  ).join('')\n}\n\nfunction onFocus (event) {\n  const elem = event.target\n  const controls = elem.getAttribute(`data-${KEY}`)\n\n  if (controls && !elem[KEY]) {\n    const mode = elem.getAttribute(`data-${KEY}-mode`) || 'suggestions'\n    const items = [].map.call(document.querySelectorAll(`#${controls} > *`), ({value}) => ({value}))\n    const parent = elem.parentElement\n\n    attr(elem, {\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'aria-controls': `${KEY}-${controls}`,\n      'aria-autocomplete': 'list',\n      'aria-haspopup': true,\n      'aria-expanded': false\n    })\n\n    parent.className = parent.className.split(' ').concat(KEY).join(' ')\n    elem[KEY] = {items, mode, list: elem.nextElementSibling} // TODO: list\n  }\n\n  if (controls) {\n    LIST.id = `${KEY}-${controls}`\n    elem.insertAdjacentElement('afterend', LIST)\n    onInput(event)\n  }\n}\n\nfunction onBlur ({target}) {\n  if (target[KEY]) {\n    attr(LIST, 'hidden', 'hidden')\n    attr(LIVE, {'aria-hidden': 'true', 'aria-live': 'polite'})\n  }\n}\n\nfunction onInput (event) {\n  const elem = event.target\n  const state = elem[KEY]\n\n  if (state) {\n    state.index = -1\n    state.value = elem.value\n    render(elem)\n    LIVE.textContent = `${state.hits.length} treff`\n  }\n}\n\nfunction onKey (event) {\n  if (event.target[KEY]) {\n    const elem = event.target\n    const state = elem[KEY]\n    if (event.keyCode === 27) onBlur(event)\n    if (event.keyCode === 38 || event.keyCode === 40) {\n      event.preventDefault()\n      const hits = [].slice.call(LIST.children)\n      const selected = hits.filter((el) => el.getAttribute('aria-selected') === 'true')[0]\n      state.index = (hits.indexOf(selected) + (event.keyCode === 38 ? -1 : 1)) % hits.length\n      LIVE.setAttribute('aria-live', 'assertive')\n\n      render(event.target)\n      const value = (state.hits[state.index] || state).value\n      if (state.mode === 'results') {\n        LIVE.textContent = value || 'Tomt tekstfelt'\n      } else {\n        elem.value = value\n      }\n    }\n  }\n}\n\nif (typeof document !== 'undefined') {\n  attr(LIST = document.createElement('ul'), {role: 'listbox'})\n  attr(LIVE = document.createElement('span'), {'aria-hidden': 'true', 'aria-live': 'polite'})\n  // document.head.insertAdjacentElement('afterbegin', '<style>.core-input{background:none}</style>'')\n  // document.documentElement.appendChild(LIVE)\n\n  // on(KEY, 'keydown', onKey)\n  // on(KEY, 'input', onInput)\n  // on(KEY, 'focus', onFocus)\n  // on(KEY, 'blur', onBlur)\n}\n\nexport function input () {\n  console.log('input')\n}\n","import React from 'react'\nimport {dialog} from './core-dialog'\n\nexport class Dialog extends React.Component {\n  componentDidMount () {\n    this.dialog = dialog(this.dialogEl, {\n      onOpenCallback: () => {\n        this.props.onOpenCallback()\n      },\n      onCloseCallback: () => {\n        this.props.onCloseCallback()\n      }\n    })\n  }\n\n  componentWillReceiveProps (nextProps) {\n    this.props.open !== nextProps.open && this.toggle(nextProps.open)\n  }\n\n  shouldComponentUpdate () {\n    return false\n  }\n\n  toggle (open) {\n    if (open) {\n      this.dialog.open()\n    } else {\n      this.dialog.close()\n    }\n  }\n\n  render () {\n    return (\n      <div className='nrk-dialog'\n        role='dialog'\n        tabIndex='-1'\n        ref={(el) => { this.dialogEl = el }}\n      >\n        {this.props.children}\n      </div>\n    )\n  }\n}\n","export function Input () {\n  return <div>Testing input</div>\n}\n"],"names":["BACKDROP","KEY","Date","now","STATES","UUID","attr","elements","attributes","getElements","forEach","element","Object","keys","name","key","let","list","slice","call","document","querySelectorAll","length","nodeType","el","weakState","object","initial","const","weakMap","get","set","uuid","state","has","Boolean","delete","createElement","role","aria-hidden","aria-live","KEY_UNIVERSAL","FOCUSABLE_ELEMENTS","getActive","querySelector","toggle","index","fn","open","autofocusElement","focusableElement","prevActive","isOpen","style","zIndex","reduce","Math","max","Number","window","getComputedStyle","getPropertyValue","removeAttribute","setAttribute","focusBeforeModalOpen","activeElement","focus","hidden","onOpenCallback","onCloseCallback","keepFocus","event","activeDialog","focusable","contains","target","exitOnEscape","keyCode","dialog","close","selector","options","this","tabindex","aria-modal","prototype","getElementById","id","classList","add","addEventListener","documentElement","appendChild","Dialog","componentDidMount","dialogEl","props","componentWillReceiveProps","nextProps","shouldComponentUpdate","render","React","className","tabIndex","ref","children","Component","console","log"],"mappings":"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"}