{"version":3,"file":"core-components.min.js","sources":["../packages/core-dialog/core-dialog.js","../packages/utils.js","../packages/core-input/core-input.js","../packages/core-input/core-input.jsx","../packages/core-dialog/core-dialog.jsx"],"sourcesContent":["import {attr, getElements, weakState} from '../utils'\n\nlet BACKDROP\nconst KEY = 'dialog-@VERSION'\nconst KEY_UNIVERSAL = 'data-dialog-xxx'\nconst FOCUSABLE_ELEMENTS = `\n  [tabindex]:not([disabled]),\n  button:not([disabled]),\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled])`\n\n// Attempt to focus on an autofocus target first. If none exists we will focus\n// on the first focusable element.\nconst focusOnFirstFocusableElement = (el) => {\n  const autofocusElement = el.querySelector('[autofocus]:not([disabled])')\n  const focusableElement = el.querySelector(FOCUSABLE_ELEMENTS)\n  ;(autofocusElement || focusableElement || el).focus()\n}\n\nconst getHighestZIndex = () =>\n  getElements('*').reduce((zIndex, el) =>\n    Math.max(zIndex, Number(window.getComputedStyle(el, null).getPropertyValue('z-index')) || 0)\n  , 0)\n\nconst getActive = () => document.querySelector(`[${KEY_UNIVERSAL}]`)\n\nconst setActiveStateForElement = (el) => {\n  const prevActive = getActive()\n  prevActive && prevActive.removeAttribute(KEY_UNIVERSAL)\n  el.setAttribute(KEY_UNIVERSAL, '')\n\n  return weakState(el, {\n    prevActive,\n    focusBeforeModalOpen: document.activeElement\n  }).get(el)\n}\n\n// Will toggle the open state of the dialog depending on what the fn function\n// returns or what (Boolean) value fn has.\nconst toggle = (el, index, fn, open = true) => {\n  const isOpen = Boolean(typeof fn === 'function' ? fn(el, index) : fn) === open\n\n  attr(el, {open: isOpen ? '' : null})\n\n  if (isOpen) {\n    el.style.zIndex = getHighestZIndex() + 1\n    setActiveStateForElement(el)\n    focusOnFirstFocusableElement(el)\n    BACKDROP.hidden = false\n    // set focus\n  } else {\n    BACKDROP.hidden = !(weakState().get(el).prevActive)\n    el.removeAttribute(KEY_UNIVERSAL)\n    if (!BACKDROP.hidden) {\n      weakState().get(el).prevActive.setAttribute(KEY_UNIVERSAL, '')\n    }\n    // Should be able to pop when removing as the last element is the active dialog\n    const state = weakState().get(el)\n    // Focus on the last focused thing before the dialog modal was opened\n    state.focusBeforeModalOpen && state.focusBeforeModalOpen.focus()\n    // Delete state for element\n    weakState(el, false)\n  }\n}\n\nconst keepFocus = (event) => {\n  const activeDialog = getActive()\n  // If no dialog is active, we don't need to do anything\n  if (!activeDialog) { return }\n\n  const state = weakState().get(activeDialog)\n  const focusable = activeDialog.querySelectorAll(FOCUSABLE_ELEMENTS)\n\n  // If focus moves us outside the dialog, we need to refocus to inside the dialog\n  if (!activeDialog.contains(event.target)) {\n    state.activeElement === focusable[0] ? focusable[focusable.length - 1].focus() : focusable[0].focus()\n  } else {\n    state.activeElement = event.target\n  }\n}\n\nconst exitOnEscape = (event) => {\n  if (event.keyCode === 27) dialog(getActive()).close()\n}\n\nexport function dialog (selector, options) {\n  if (!(this instanceof dialog)) return new dialog(selector, options) //eslint-disable-line\n\n  // Initialize the element with necessary attributes for a dialog\n  this.elements = attr(getElements(selector), {\n    role: 'dialog',\n    tabindex: -1,\n    'aria-modal': true\n  })\n\n  return this\n}\n\ndialog.prototype.open = function (fn = true) {\n  this.elements.forEach((el, index) => toggle(el, index, fn))\n  return this\n}\n\ndialog.prototype.close = function (fn = false) {\n  this.elements.forEach((el, index) => toggle(el, index, fn))\n  return this\n}\n\nexport function createBackdrop () {\n  attr(BACKDROP = document.createElement('div'), {hidden: true, id: KEY})\n  // @todo: General styling. Should be removed?\n  BACKDROP.classList.add('nrk-dialog-backdrop')\n  document.addEventListener('focus', keepFocus, true)\n  document.addEventListener('keydown', exitOnEscape)\n  document.documentElement.appendChild(BACKDROP)\n}\n\nif (typeof document !== 'undefined' && !document.getElementById(KEY)) {\n  createBackdrop()\n}\n","const KEY = `core-components-${Date.now()}`\nconst STATES = {}\nlet UUID = 0\n\nexport function assign (target, ...sources) {\n  sources.filter(Boolean).forEach((source) => {\n    Object.keys(source).forEach((key) => (target[key] = source[key]))\n  })\n  return target\n}\n\nexport function attr (elements, attributes) {\n  getElements(elements).forEach((element) => {\n    Object.keys(attributes).forEach((name) => {\n      element[`${attributes[name] === null ? 'remove' : 'set'}Attribute`](name, attributes[name])\n    })\n  })\n  return elements\n}\n\nexport const closest = (element, nodeName) => {\n  for (var el = element; el; el = el.parentElement) {\n    if (el.nodeName.toLowerCase() === nodeName) return el\n  }\n}\n\nexport function getElements (elements) {\n  if (typeof elements === 'string') return getElements(document.querySelectorAll(elements))\n  if (elements && elements.length) return [].slice.call(elements)\n  if (elements && elements.nodeType) return [elements]\n  return []\n}\n\nexport function weakState (element, object, initial = {}) {\n  const weakMap = {\n    get: (element) => STATES[element[KEY]],\n    set: (element, object) => {\n      const uuid = element[KEY] || (element[KEY] = ++UUID)\n      const state = STATES[uuid] || (STATES[uuid] = initial)\n      Object.keys(object).forEach((key) => (state[key] = object[key]))\n      return state\n    },\n    has: (element) => Boolean(STATES[element[KEY]]),\n    delete: (element) => {\n      if (!weakMap.get(element)) return false\n      delete element[KEY]\n      delete STATES[element[KEY]]\n      return true\n    }\n  }\n\n  if (object === false) {\n    weakMap.delete(element)\n  } else if (typeof object === 'object') {\n    weakMap.set(element, object)\n  }\n\n  return weakMap\n}\n\nexport const queryAll = (selector, context = document) =>\n  [].slice.call(context.querySelectorAll(selector))\n","import {attr} from '../utils'\n\nconst KEY = 'input-@VERSION'\nlet LIST // Element to contain list\nlet LIVE // Element to contain screen reader text\n\nfunction render (elem) {\n  const state = elem[KEY]\n  const value = state.value.trim().toLowerCase()\n  state.hits = state.items.filter((item) => item.value.toLowerCase().indexOf(value) !== -1)\n\n  attr(LIVE, {'aria-hidden': false})\n  attr(LIST, {'hidden': state.hits.length ? null : true})\n  attr(elem, {'aria-expanded': Boolean(state.hits.length)})\n\n  LIST.style.width = `${elem.offsetWidth}px`\n  LIST.innerHTML = state.hits.map(({value}, i) =>\n    `<li role=\"option\" aria-selected=\"${i === state.index}\">${value}</li>`\n  ).join('')\n}\n\nfunction onFocus (event) {\n  const elem = event.target\n  const controls = elem.getAttribute(`data-${KEY}`)\n\n  if (controls && !elem[KEY]) {\n    const mode = elem.getAttribute(`data-${KEY}-mode`) || 'suggestions'\n    const items = [].map.call(document.querySelectorAll(`#${controls} > *`), ({value}) => ({value}))\n    const parent = elem.parentElement\n\n    attr(elem, {\n      'role': 'combobox',\n      'autocomplete': 'off',\n      'aria-controls': `${KEY}-${controls}`,\n      'aria-autocomplete': 'list',\n      'aria-haspopup': true,\n      'aria-expanded': false\n    })\n\n    parent.className = parent.className.split(' ').concat(KEY).join(' ')\n    elem[KEY] = {items, mode, list: elem.nextElementSibling} // TODO: list\n  }\n\n  if (controls) {\n    LIST.id = `${KEY}-${controls}`\n    elem.insertAdjacentElement('afterend', LIST)\n    onInput(event)\n  }\n}\n\nfunction onBlur ({target}) {\n  if (target[KEY]) {\n    attr(LIST, 'hidden', 'hidden')\n    attr(LIVE, {'aria-hidden': 'true', 'aria-live': 'polite'})\n  }\n}\n\nfunction onInput (event) {\n  const elem = event.target\n  const state = elem[KEY]\n\n  if (state) {\n    state.index = -1\n    state.value = elem.value\n    render(elem)\n    LIVE.textContent = `${state.hits.length} treff`\n  }\n}\n\nfunction onKey (event) {\n  if (event.target[KEY]) {\n    const elem = event.target\n    const state = elem[KEY]\n    if (event.keyCode === 27) onBlur(event)\n    if (event.keyCode === 38 || event.keyCode === 40) {\n      event.preventDefault()\n      const hits = [].slice.call(LIST.children)\n      const selected = hits.filter((el) => el.getAttribute('aria-selected') === 'true')[0]\n      state.index = (hits.indexOf(selected) + (event.keyCode === 38 ? -1 : 1)) % hits.length\n      LIVE.setAttribute('aria-live', 'assertive')\n\n      render(event.target)\n      const value = (state.hits[state.index] || state).value\n      if (state.mode === 'results') {\n        LIVE.textContent = value || 'Tomt tekstfelt'\n      } else {\n        elem.value = value\n      }\n    }\n  }\n}\n\nif (typeof document !== 'undefined') {\n  attr(LIST = document.createElement('ul'), {role: 'listbox'})\n  attr(LIVE = document.createElement('span'), {'aria-hidden': 'true', 'aria-live': 'polite'})\n\n  // document.head.insertAdjacentElement('afterbegin', `<style>\n  //   .core-input { background: none }\n  // </style>`)\n\n  // document.addEventListener('keydown', onKey)\n  // document.addEventListener('input', onInput)\n  // document.addEventListener('focus', onFocus, true) // Use capture to ensure event bubling\n  // document.addEventListener('blur', onBlur, true)   // Use capture to ensure event bubling\n  // document.documentElement.appendChild(LIVE)\n}\n\nexport function input () {\n  console.log('input')\n}\n","export function Input () {\n  return <div>Testing input</div>\n}\n","export function Dialog () {\n  return <div>Testing dialog</div>\n}\n"],"names":["BACKDROP","KEY","Date","now","STATES","UUID","attr","elements","attributes","getElements","forEach","element","Object","keys","name","document","querySelectorAll","length","slice","call","nodeType","weakState","object","initial","const","weakMap","get","set","uuid","state","key","has","Boolean","delete","createElement","role","aria-hidden","aria-live","KEY_UNIVERSAL","FOCUSABLE_ELEMENTS","getActive","querySelector","toggle","el","index","fn","open","autofocusElement","focusableElement","prevActive","isOpen","style","zIndex","reduce","Math","max","Number","window","getComputedStyle","getPropertyValue","removeAttribute","setAttribute","focusBeforeModalOpen","activeElement","focus","hidden","keepFocus","event","activeDialog","focusable","contains","target","exitOnEscape","keyCode","dialog","close","selector","options","this","tabindex","aria-modal","prototype","getElementById","id","classList","add","addEventListener","documentElement","appendChild","console","log","React"],"mappings":"qMAEIA,ECFEC,EAAM,mBAAmBC,KAAKC,MAC9BC,KACFC,EAAO,EASX,SAAgBC,EAAMC,EAAUC,GAM9B,OALAC,EAAYF,GAAUG,iBAASC,GAC7BC,OAAOC,KAAKL,GAAYE,iBAASI,GAC/BH,GAAgC,OAArBH,EAAWM,GAAiB,SAAW,oBAAkBA,EAAMN,EAAWM,QAGlFP,EAST,SAAgBE,EAAaF,GAC3B,MAAwB,iBAAbA,EAA8BE,EAAYM,SAASC,iBAAiBT,IAC3EA,GAAYA,EAASU,UAAkBC,MAAMC,KAAKZ,GAClDA,GAAYA,EAASa,UAAkBb,MAI7C,SAAgBc,EAAWV,EAASW,EAAQC,sBAC1CC,IAAMC,GACJC,aAAMf,UAAYP,EAAOO,EAAQV,KACjC0B,aAAMhB,EAASW,GACbE,IAAMI,EAAOjB,EAAQV,KAASU,EAAQV,KAASI,GACzCwB,EAAQzB,EAAOwB,KAAUxB,EAAOwB,GAAQL,GAE9C,OADAX,OAAOC,KAAKS,GAAQZ,iBAASoB,UAASD,EAAMC,GAAOR,EAAOQ,KACnDD,GAETE,aAAMpB,UAAYqB,QAAQ5B,EAAOO,EAAQV,MACzCgC,gBAAStB,GACP,QAAKc,EAAQC,IAAIf,YACVA,EAAQV,UACRG,EAAOO,EAAQV,KACf,KAUX,OANe,IAAXqB,EACFG,EAAQQ,OAAOtB,GACY,iBAAXW,GAChBG,EAAQE,IAAIhB,EAASW,GAGhBG,ECmCe,oBAAbV,WACTT,EAAYS,SAASmB,cAAc,OAAQC,KAAM,YACjD7B,EAAYS,SAASmB,cAAc,SAAUE,cAAe,OAAQC,YAAa,YF3FnFb,IAAMvB,EAAM,kBACNqC,EAAgB,kBAChBC,EAAqB,8IAoBrBC,oBAAkBzB,SAAS0B,kBAAkBH,QAe7CI,WAAUC,EAAIC,EAAOC,EAAIC,mBAAO,GACpCtB,IA3BoCmB,EAC9BI,EACAC,EAW0BL,EAC1BM,EAaAC,EAASlB,QAAsB,mBAAPa,EAAoBA,EAAGF,EAAIC,GAASC,KAAQC,EAI1E,GAFAxC,EAAKqC,GAAKG,KAAMI,EAAS,GAAK,OAE1BA,EACFP,EAAGQ,MAAMC,OAzBX3C,EAAY,KAAK4C,gBAAQD,EAAQT,UAC/BW,KAAKC,IAAIH,EAAQI,OAAOC,OAAOC,iBAAiBf,EAAI,MAAMgB,iBAAiB,aAAe,IAC1F,GAuBuC,EAnBThB,EAoBLA,GAnBrBM,EAAaT,MACLS,EAAWW,gBAAgBtB,GACzCK,EAAGkB,aAAavB,EAAe,IAExBjB,EAAUsB,cACfM,EACAa,qBAAsB/C,SAASgD,gBAC9BrC,IAAIiB,GApBDI,GAD8BJ,EAkCLA,GAjCHF,cAAc,+BACpCO,EAAmBL,EAAGF,cAAcF,IACxCQ,GAAoBC,GAAoBL,GAAIqB,QAgC5ChE,EAASiE,QAAS,MAEb,CACLjE,EAASiE,QAAW5C,IAAYK,IAAIiB,GAAc,WAClDA,EAAGiB,gBAAgBtB,GACdtC,EAASiE,QACZ5C,IAAYK,IAAIiB,GAAIM,WAAWY,aAAavB,EAAe,IAG7Dd,IAAMK,EAAQR,IAAYK,IAAIiB,GAE9Bd,EAAMiC,sBAAwBjC,EAAMiC,qBAAqBE,QAEzD3C,EAAUsB,GAAI,KAIZuB,WAAaC,GACjB3C,IAAM4C,EAAe5B,IAErB,GAAK4B,EAAL,CAEA5C,IAAMK,EAAQR,IAAYK,IAAI0C,GACxBC,EAAYD,EAAapD,iBAAiBuB,GAG3C6B,EAAaE,SAASH,EAAMI,QAG/B1C,EAAMkC,cAAgBI,EAAMI,OAF5B1C,EAAMkC,gBAAkBM,EAAU,GAAKA,EAAUA,EAAUpD,OAAS,GAAG+C,QAAUK,EAAU,GAAGL,UAM5FQ,WAAgBL,GACE,KAAlBA,EAAMM,SAAgBC,EAAOlC,KAAamC,SAGhD,SAAgBD,EAAQE,EAAUC,GAChC,OAAMC,gBAAgBJ,GAGtBI,KAAKvE,SAAWD,EAAKG,EAAYmE,IAC/BzC,KAAM,SACN4C,UAAW,EACXC,cAAc,IAGTF,MAT+B,IAAIJ,EAAOE,EAAUC,GAY7DH,EAAOO,UAAUnC,KAAO,SAAUD,GAEhC,uBAFqC,GACrCiC,KAAKvE,SAASG,iBAASiC,EAAIC,UAAUF,EAAOC,EAAIC,EAAOC,KAChDiC,MAGTJ,EAAOO,UAAUN,MAAQ,SAAU9B,GAEjC,uBAFsC,GACtCiC,KAAKvE,SAASG,iBAASiC,EAAIC,UAAUF,EAAOC,EAAIC,EAAOC,KAChDiC,MAYe,oBAAb/D,UAA6BA,SAASmE,eAAejF,KAR9DK,EAAKN,EAAWe,SAASmB,cAAc,QAAS+B,QAAQ,EAAMkB,GAAIlF,IAElED,EAASoF,UAAUC,IAAI,uBACvBtE,SAASuE,iBAAiB,QAASpB,GAAW,GAC9CnD,SAASuE,iBAAiB,UAAWd,GACrCzD,SAASwE,gBAAgBC,YAAYxF,8BERvC,WACEyF,QAAQC,IAAI,kBC5GP,WACL,OAAOC,+BAAK,sCCDP,WACL,OAAOA,+BAAK"}